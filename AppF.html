<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Word Recording App</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 600px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        #word-boxes { 
            display: flex; 
            gap: 10px; 
            margin-bottom: 20px; 
        }
        .word-box { 
            border: 2px solid #ddd; 
            padding: 10px; 
            text-align: center; 
            flex-grow: 1; 
        }
        .word-box.completed { 
            background-color: #e6f3e6; 
            border-color: green; 
        }
        .word-box.current { 
            border-color: blue; 
            font-weight: bold; 
        }
        .hidden { 
            display: none; 
        }
        #previous-recordings {
            margin-top: 10px;
        }
        #previous-audio-list audio {
            margin-bottom: 10px;
            width: 100%;
        }
        #user-id-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #user-id-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="user-id-modal" class="hidden">
        <div id="user-id-container">
            <h2>Enter User ID</h2>
            <input type="text" id="user-id-input" placeholder="Enter your unique user ID">
            <button id="save-user-id">Save User ID</button>
        </div>
    </div>

    <div id="app">
        <h1>Word Recording Tracker</h1>
        <div id="word-boxes"></div>
        <div id="word-display"></div>
        <div id="mode-status"></div>
        <div id="recording-controls">
            <button id="start-recording">Start Recording</button>
            <button id="stop-recording" disabled>Stop Recording</button>
            <button id="play-recording" disabled>Play Recording</button>
            <button id="save-recording" disabled>Save Recording</button>
            <button id="retry-recording" class="hidden">Retry Recording</button>
        </div>
        <div id="previous-recordings">
            <button id="show-previous-recordings">Play Previous Recordings</button>
            <div id="previous-audio-list"></div>
        </div>
        <div id="completion-message" class="hidden">
            All modes completed!
            <button id="next-word" class="hidden">Next Word</button>
        </div>
    </div>

    <script>
        class WordRecordingTracker {
            constructor() {
                this.words = [
                    {
                        word: "hello world",
                        modes: ["fast", "normal", "slow", "soft", "comfortable"]
                    }
                ];
                this.completedModes = {};
                this.modeAudioFiles = {};
                this.userId = null;
                this.loadState();
            }

            loadState() {
                // Load user ID
                this.userId = localStorage.getItem('userId');
                
                // If no user ID, show modal
                if (!this.userId) {
                    document.getElementById('user-id-modal').classList.remove('hidden');
                }

                // Load state with user-specific key
                const storageKey = this.getUserStorageKey();
                const savedState = JSON.parse(localStorage.getItem(storageKey) || '{}');
                
                this.completedModes = savedState.completedModes || {};
                this.modeAudioFiles = savedState.modeAudioFiles || {};
                
                // Preserve audio files by checking if they exist
                for (const word in this.modeAudioFiles) {
                    for (const mode in this.modeAudioFiles[word]) {
                        const audioUrl = this.modeAudioFiles[word][mode];
                        
                        // Verify audio URL still exists
                        fetch(audioUrl)
                            .catch(() => {
                                // If fetch fails, remove the audio URL
                                delete this.modeAudioFiles[word][mode];
                                delete this.completedModes[word][mode];
                            });
                    }
                }

                this.renderWordBoxes();
            }

            getUserStorageKey() {
                return `wordRecordingState_${this.userId || 'anonymous'}`;
            }

            saveState() {
                const storageKey = this.getUserStorageKey();
                localStorage.setItem(storageKey, JSON.stringify({
                    completedModes: this.completedModes,
                    modeAudioFiles: this.modeAudioFiles
                }));
            }

            setUserId(userId) {
                if (userId && userId.trim()) {
                    localStorage.setItem('userId', userId);
                    this.userId = userId;
                    this.loadState(); // Reload state with new user ID
                    document.getElementById('user-id-modal').classList.add('hidden');
                }
            }

            renderWordBoxes() {
                const wordBoxesContainer = document.getElementById('word-boxes');
                wordBoxesContainer.innerHTML = '';

                const currentWord = this.words[0];
                currentWord.modes.forEach((mode) => {
                    const wordBox = document.createElement('div');
                    wordBox.classList.add('word-box');
                    
                    const isCompleted = this.completedModes[currentWord.word]?.[mode];
                    const isCurrentMode = this.getNextPendingMode() === mode;

                    if (isCompleted) wordBox.classList.add('completed');
                    if (isCurrentMode) wordBox.classList.add('current');

                    wordBox.textContent = `${currentWord.word} - ${mode}`;
                    wordBoxesContainer.appendChild(wordBox);
                });
            }

            getNextPendingMode() {
                const currentWord = this.words[0];
                const wordKey = currentWord.word;

                if (!this.completedModes[wordKey]) {
                    this.completedModes[wordKey] = {};
                }

                for (let mode of currentWord.modes) {
                    if (!this.completedModes[wordKey][mode]) {
                        return mode;
                    }
                }

                return null;
            }

            getCompletedModesInOrder() {
                const currentWord = this.words[0];
                const wordKey = currentWord.word;
                
                return currentWord.modes.filter(
                    mode => this.completedModes[wordKey]?.[mode]
                );
            }

            markModeComplete(mode, audioBlob) {
                const currentWord = this.words[0];
                const wordKey = currentWord.word;
                
                if (audioBlob) {
                    // Save audio file
                    const fileName = `Audio_${mode}.wav`;
                    const audioFile = new File([audioBlob], fileName, { type: 'audio/wav' });
                    
                    // Store file in modeAudioFiles
                    if (!this.modeAudioFiles[wordKey]) {
                        this.modeAudioFiles[wordKey] = {};
                    }
                    this.modeAudioFiles[wordKey][mode] = URL.createObjectURL(audioFile);

                    // Mark mode as completed
                    this.completedModes[wordKey][mode] = true;
                    this.saveState();
                    this.renderWordBoxes();
                    return true;
                }
                return false;
            }

            isAllModesComplete() {
                const currentWord = this.words[0];
                return currentWord.modes.every(
                    mode => this.completedModes[currentWord.word]?.[mode]
                );
            }

            resetRecording() {
                const currentWord = this.words[0];
                this.completedModes = {};
                this.modeAudioFiles = {};
                localStorage.removeItem('wordRecordingState');
                this.renderWordBoxes();
            }
            // ... [rest of the methods remain the same as in the previous implementation]
        }

        // Application Initialization
        const tracker = new WordRecordingTracker();
        let mediaRecorder;
        let audioChunks = [];
        let audioUrl = null;

        // DOM Elements
        const userIdModal = document.getElementById('user-id-modal');
        const userIdInput = document.getElementById('user-id-input');
        const saveUserIdBtn = document.getElementById('save-user-id');
        const wordDisplay = document.getElementById('word-display');
        const modeStatus = document.getElementById('mode-status');
        const startRecordingBtn = document.getElementById('start-recording');
        const stopRecordingBtn = document.getElementById('stop-recording');
        const playRecordingBtn = document.getElementById('play-recording');
        const saveRecordingBtn = document.getElementById('save-recording');
        const retryRecordingBtn = document.getElementById('retry-recording');
        const recordingControls = document.getElementById('recording-controls');
        const completionMessage = document.getElementById('completion-message');
        const nextWordBtn = document.getElementById('next-word');
        const previousAudioListContainer = document.getElementById('previous-audio-list');
        const showPreviousRecordingsBtn = document.getElementById('show-previous-recordings');

        // User ID Save Event Listener
        saveUserIdBtn.addEventListener('click', () => {
            tracker.setUserId(userIdInput.value);
        });
         // Recording Functions
         async function startRecording() {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            
            audioChunks = [];
            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                if (audioChunks.length > 0) {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    audioUrl = URL.createObjectURL(audioBlob);
                    
                    playRecordingBtn.disabled = false;
                    saveRecordingBtn.disabled = false;
                    retryRecordingBtn.classList.remove('hidden');
                    startRecordingBtn.disabled = true;
                    stopRecordingBtn.disabled = true;
                }
            };

            mediaRecorder.start();
            startRecordingBtn.disabled = true;
            stopRecordingBtn.disabled = false;
            
            // Reset play button if no recording exists
            playRecordingBtn.disabled = true;
        }

        function stopRecording() {
            mediaRecorder.stop();
            startRecordingBtn.disabled = false;
            stopRecordingBtn.disabled = true;
        }

        function playRecording() {
            if (audioUrl) {
                const audio = new Audio(audioUrl);
                audio.play();
            }
        }

        function playPreviousRecordings() {
            const currentWord = tracker.words[0];
            const wordKey = currentWord.word;
            
            // Clear previous audio list
            previousAudioListContainer.innerHTML = '';

            // Get completed modes in order
            const completedModes = tracker.getCompletedModesInOrder();

            // If no recordings exist, show a message
            if (completedModes.length === 0) {
                previousAudioListContainer.innerHTML = 'No previous recordings found.';
                return;
            }

            // Create an audio player for each completed mode's recording
            completedModes.forEach(mode => {
                const audioUrl = tracker.modeAudioFiles[wordKey]?.[mode];
                
                if (audioUrl) {
                    // Create a container for each audio
                    const audioContainer = document.createElement('div');
                    
                    // Create mode label with filename
                    const modeLabel = document.createElement('strong');
                    const fileName = `Audio_${mode}.wav`;
                    modeLabel.textContent = `${mode} mode (${fileName}): `;
                    
                    // Create audio element
                    const audioElement = document.createElement('audio');
                    audioElement.src = audioUrl;
                    audioElement.controls = true;
                    
                    // Append elements
                    audioContainer.appendChild(modeLabel);
                    audioContainer.appendChild(audioElement);
                    
                    previousAudioListContainer.appendChild(audioContainer);
                }
            });
        }

        function saveRecording() {
            const currentWord = tracker.words[0];
            const currentMode = tracker.getNextPendingMode();
            
            // Only allow save if recording exists
            if (audioChunks.length > 0) {
                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                const modeCompleted = tracker.markModeComplete(currentMode, audioBlob);
                
                if (modeCompleted) {
                    audioUrl = null;
                    audioChunks = [];
                    playRecordingBtn.disabled = true;
                    saveRecordingBtn.disabled = true;
                    retryRecordingBtn.classList.add('hidden');
                    startRecordingBtn.disabled = false;

                    if (tracker.isAllModesComplete()) {
                        recordingControls.classList.add('hidden');
                        completionMessage.classList.remove('hidden');
                        nextWordBtn.classList.remove('hidden');
                    }

                    updateDisplay();
                }
            }
        }

        function retryRecording() {
            // Reset recording UI
            audioUrl = null;
            audioChunks = [];
            playRecordingBtn.disabled = true;
            saveRecordingBtn.disabled = true;
            retryRecordingBtn.classList.add('hidden');
            startRecordingBtn.disabled = false;
        }

        function updateDisplay() {
            const currentWord = tracker.words[0];
            const nextMode = tracker.getNextPendingMode();

            wordDisplay.textContent = `Word: ${currentWord.word}`;
            modeStatus.textContent = nextMode 
                ? `Current Mode: ${nextMode}` 
                : 'All modes completed!';
            
            tracker.renderWordBoxes();
        }

        // Event Listeners
        startRecordingBtn.addEventListener('click', startRecording);
        stopRecordingBtn.addEventListener('click', stopRecording);
        playRecordingBtn.addEventListener('click', playRecording);
        saveRecordingBtn.addEventListener('click', saveRecording);
        retryRecordingBtn.addEventListener('click', retryRecording);
        showPreviousRecordingsBtn.addEventListener('click', playPreviousRecordings);
        nextWordBtn.addEventListener('click', () => {
            tracker.resetRecording();
            recordingControls.classList.remove('hidden');
            completionMessage.classList.add('hidden');
            nextWordBtn.classList.add('hidden');
            updateDisplay();
            
            // Reset audio playback
            previousAudioListContainer.innerHTML = '';
        });

        // Initial display update
        updateDisplay();
        // ... [rest of the event listeners and functions remain the same as in the previous implementation]
    </script>
</body>
</html>