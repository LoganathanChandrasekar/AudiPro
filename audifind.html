<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Word Recording App</title>
    <style>
        body { font-family: Arial; max-width: 600px; margin: 0 auto; padding: 20px; }
        #word-boxes { display: flex; gap: 10px; margin-bottom: 20px; }
        .word-box { 
            border: 2px solid #ddd; 
            padding: 10px; 
            text-align: center; 
            flex-grow: 1; 
        }
        .word-box.completed { 
            background-color: #e6f3e6; 
            border-color: green; 
        }
        .word-box.current { 
            border-color: blue; 
            font-weight: bold; 
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>Word Recording Tracker</h1>
        <div id="word-boxes"></div>
        <div id="word-display"></div>
        <div id="mode-status"></div>
        <button id="start-recording">Start Recording</button>
        <button id="stop-recording" disabled>Stop Recording</button>
        <button id="play-recording" disabled>Play Recording</button>
        <button id="save-recording" disabled>Save Recording</button>
        <button id="save-progress">Save Progress</button>
        <textarea id="progress-code" rows="4" readonly placeholder="Progress Code"></textarea>
    </div>

    <script>
        class ProgressManager {
            constructor() {
                this.storageKey = 'wordRecordingProgress';
            }

            // Generate unique progress identifier
            generateProgressCode() {
                return btoa(JSON.stringify({
                    timestamp: Date.now(),
                    random: Math.random().toString(36).substring(2)
                }));
            }

            // Save current progress
            saveProgress(progressData) {
                // Encrypt and save locally
                localStorage.setItem(this.storageKey, JSON.stringify(progressData));
                
                // Generate sharable progress code
                return this.generateProgressCode();
            }

            // Retrieve saved progress
            retrieveProgress() {
                const savedProgress = localStorage.getItem(this.storageKey);
                return savedProgress ? JSON.parse(savedProgress) : null;
            }

            // Import progress from code
            importProgress(progressCode) {
                try {
                    // In a real-world scenario, validate progress code 
                    // against a backend service
                    const decodedData = JSON.parse(atob(progressCode));
                    return decodedData;
                } catch (error) {
                    console.error('Invalid progress code');
                    return null;
                }
            }
        }

        class WordRecordingTracker {
            constructor() {
                this.progressManager = new ProgressManager();
                this.words = [
                    {
                        word: "hello world",
                        modes: ["fast", "normal", "slow", "soft", "comfortable"]
                    }
                ];
                this.completedModes = {};
                this.loadState();
            }

            loadState() {
                const savedProgress = this.progressManager.retrieveProgress();
                if (savedProgress) {
                    this.completedModes = savedProgress.completedModes || {};
                }
                this.renderWordBoxes();
            }

            saveState() {
                const progressCode = this.progressManager.saveProgress({
                    completedModes: this.completedModes
                });
                
                // Display progress code
                document.getElementById('progress-code').value = progressCode;
            }

            renderWordBoxes() {
                const wordBoxesContainer = document.getElementById('word-boxes');
                wordBoxesContainer.innerHTML = '';

                const currentWord = this.words[0];
                currentWord.modes.forEach((mode) => {
                    const wordBox = document.createElement('div');
                    wordBox.classList.add('word-box');
                    
                    const isCompleted = this.completedModes[currentWord.word]?.[mode];
                    const isCurrentMode = this.getNextPendingMode() === mode;

                    if (isCompleted) wordBox.classList.add('completed');
                    if (isCurrentMode) wordBox.classList.add('current');

                    wordBox.textContent = `${currentWord.word} - ${mode}`;
                    wordBoxesContainer.appendChild(wordBox);
                });
            }

            getNextPendingMode() {
                const currentWord = this.words[0];
                const wordKey = currentWord.word;

                if (!this.completedModes[wordKey]) {
                    this.completedModes[wordKey] = {};
                }

                for (let mode of currentWord.modes) {
                    if (!this.completedModes[wordKey][mode]) {
                        return mode;
                    }
                }

                return null;
            }

            markModeComplete(mode) {
                const currentWord = this.words[0];
                const wordKey = currentWord.word;
                
                this.completedModes[wordKey][mode] = true;
                this.renderWordBoxes();
            }
        }

        // Application Initialization
        const tracker = new WordRecordingTracker();
        let mediaRecorder;
        let audioChunks = [];

        // DOM Elements
        const wordDisplay = document.getElementById('word-display');
        const modeStatus = document.getElementById('mode-status');
        const startRecordingBtn = document.getElementById('start-recording');
        const stopRecordingBtn = document.getElementById('stop-recording');
        const playRecordingBtn = document.getElementById('play-recording');
        const saveRecordingBtn = document.getElementById('save-recording');
        const saveProgressBtn = document.getElementById('save-progress');

        // Recording Functions
        async function startRecording() {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            
            audioChunks = [];
            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(audioBlob);
                
                playRecordingBtn.disabled = false;
                saveRecordingBtn.disabled = false;

                playRecordingBtn.onclick = () => {
                    const audio = new Audio(audioUrl);
                    audio.play();
                };
            };

            mediaRecorder.start();
            startRecordingBtn.disabled = true;
            stopRecordingBtn.disabled = false;
        }

        function stopRecording() {
            mediaRecorder.stop();
            startRecordingBtn.disabled = false;
            stopRecordingBtn.disabled = true;
        }

        function saveRecording() {
            const currentWord = tracker.words[0];
            const currentMode = tracker.getNextPendingMode();
            
            // Mark mode as complete
            tracker.markModeComplete(currentMode);
            
            // Reset UI
            saveRecordingBtn.disabled = true;
            playRecordingBtn.disabled = true;

            updateDisplay();
        }

        function updateDisplay() {
            const currentWord = tracker.words[0];
            const nextMode = tracker.getNextPendingMode();

            wordDisplay.textContent = `Word: ${currentWord.word}`;
            modeStatus.textContent = nextMode 
                ? `Current Mode: ${nextMode}` 
                : 'All modes completed!';
            
            tracker.renderWordBoxes();
        }

        // Save Progress Button
        saveProgressBtn.addEventListener('click', () => {
            tracker.saveState();
        });

        // Initialize event listeners
        startRecordingBtn.addEventListener('click', startRecording);
        stopRecordingBtn.addEventListener('click', stopRecording);
        saveRecordingBtn.addEventListener('click', saveRecording);

        // Initial display update
        updateDisplay();
    </script>
</body>
</html>